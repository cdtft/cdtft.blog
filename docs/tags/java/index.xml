<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on cdftf@qq.com</title>
    <link>https://cdtft.github.io/cdtft.blog/tags/java/</link>
    <description>Recent content in java on cdftf@qq.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 23 Mar 2020 14:40:37 +0800</lastBuildDate>
    
	<atom:link href="https://cdtft.github.io/cdtft.blog/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>单例延迟初始化</title>
      <link>https://cdtft.github.io/cdtft.blog/post/myfirst/</link>
      <pubDate>Mon, 23 Mar 2020 14:40:37 +0800</pubDate>
      
      <guid>https://cdtft.github.io/cdtft.blog/post/myfirst/</guid>
      <description>类会何时被初始化 有一下几种情况类会初始化
 虚拟机启动的时候，初始化用户指定的主类 遇到new 调用静态方法时，初始化该静态方法所在的类 访问静态字段，初始化该静态字段所在的类 子类的初始化触发父类的初始化 定义了default接口，直接实现或间接实现该接口的类初始化会触发该接口的初始化 使用反射API对某个类反射调用时 初次调用Methodhandle实例时，初始化Methodhandle指向的方法所在的类  使用第4条规范实现单例模式 public class Singleton { private Singleton() { } private static class LazyHolder { private final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance() { return LazyHolder.INSTANCE; } } 该单例是线程安全的</description>
    </item>
    
  </channel>
</rss>